# -*- coding: utf-8 -*-
"""AED2Final2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ggILTTwrU9WBc1TDtUY1Ae3MLWxc5Hyl
"""

import networkx as nx
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import tempfile
import os

# Config: pasta para salvar figuras
output_dir = 'figures'
os.makedirs(output_dir, exist_ok=True)

# Preprocess GEXF to handle empty numeric attributes
orig_path = 'final_netwokr.gexf'  # ajuste o caminho se necess√°rio
with open(orig_path, 'r', encoding='utf-8') as f:
    data = f.read()
# substitute empty attribute values by zero (ou outro default)
cleaned = data.replace('value=""', 'value="0"')
# write to temp file
tmp = tempfile.NamedTemporaryFile('w', delete=False, suffix='.gexf', encoding='utf-8')
tmp.write(cleaned)
tmp_path = tmp.name
tmp.close()

# Load the cleaned graph
G = nx.read_gexf(tmp_path)
# remove temp file
os.unlink(tmp_path)

# If multigraph, convert to simple Graph (merge parallel edges)
if G.is_multigraph():
    G = nx.Graph(G)

# Compute node-level metrics
degree_dict = dict(G.degree())
betweenness_dict = nx.betweenness_centrality(G)
eigenvector_dict = nx.eigenvector_centrality(G, max_iter=1000)
closeness_dict = nx.closeness_centrality(G)

# Build a DataFrame
df = pd.DataFrame({
    'Degree': list(degree_dict.values()),
    'Betweenness': list(betweenness_dict.values()),
    'Eigenvector': list(eigenvector_dict.values()),
    'Closeness': list(closeness_dict.values())
})

# 1) Degree distribution: histogram + PDF
degrees = df['Degree']
fig, ax1 = plt.subplots(figsize=(8, 5))
sns.histplot(degrees, bins=10, color='skyblue', edgecolor='black', ax=ax1, label='Count')
ax1.set_xlabel('Degree')
ax1.set_ylabel('Count')
ax2 = ax1.twinx()
sns.kdeplot(degrees, ax=ax2, color='red', lw=2, label='PDF')
ax2.set_ylabel('Probability')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
plt.title('Degree Distribution with PDF Overlay')
plt.tight_layout()
# Salvar figura
fig.savefig(os.path.join(output_dir, 'degree_pdf.png'), dpi=300)
plt.show()

# 2) Degree distribution: histogram + CDF
fig, ax1 = plt.subplots(figsize=(8, 5))
sns.histplot(degrees, bins=10, color='skyblue', edgecolor='black', ax=ax1, label='Count')
ax1.set_xlabel('Degree')
ax1.set_ylabel('Count')
ax2 = ax1.twinx()
sns.ecdfplot(degrees, ax=ax2, color='red', lw=2, label='CDF')
ax2.set_ylabel('Probability')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
plt.title('Degree Distribution with CDF Overlay')
plt.tight_layout()
# Salvar figura
fig.savefig(os.path.join(output_dir, 'degree_cdf.png'), dpi=300)
plt.show()

# 3) PairGrid of all metrics
sns.set(style='whitegrid')
g = sns.PairGrid(df, diag_sharey=False)
g.map_upper(sns.scatterplot, s=40, color='tomato', edgecolor='white')
g.map_lower(sns.kdeplot, cmap='Reds_r', fill=True)
g.map_diag(sns.kdeplot, lw=2, legend=False)
g.fig.suptitle('Pairwise Relationships of Network Metrics', y=1.02)
plt.tight_layout()
# Salvar figura
g.fig.savefig(os.path.join(output_dir, 'pairgrid_metrics.png'), dpi=300)
plt.show()